# -*- coding: utf-8 -*-
"""Anees_GSOC2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16SMj8dUHKSQmBSby_MVdlbqKS8oqVKYs

**ANEES ASLAM** 

**I** ðŸ’™ **JdeROBOT**

Python Challenge
"""

!pip install imageio

import numpy as np
import matplotlib.pyplot as plt
import imageio


class Robot:
    def __init__(self, position, direction, speed=1, arena_size=1000):
        self.position = position
        self.direction = direction
        self.speed = speed
        self.arena_size = arena_size
    def update(self, boundary):
        # Move the robot in the current direction
        self.position += self.direction
        if self.position[0] < 0:
          self.position[0] = 0
        elif self.position[0] >= self.arena_size:
          self.position[0] = self.arena_size - 1

        if self.position[1] < 0:
            self.position[1] = 0
        elif self.position[1] >= self.arena_size:
            self.position[1] = self.arena_size - 1
            

        # Check if the new position is out of bounds
        if self.position[0] < 0 or self.position[0] >= self.arena_size or \
                self.position[1] < 0 or self.position[1] >= self.arena_size:
            # If the new position is out of bounds, rotate the robot and move it forward
            self.direction = rotate(self.direction, np.random.normal(scale=0.1))
            self.position += self.direction
        else:
            # If the new position is within bounds, add some random noise to the robot's direction
            self.direction = rotate(self.direction, np.random.normal(scale=0.1))

        # Update the boundary with the position of the robot
        boundary[int(self.position[1]), int(self.position[0])] = 1

        return boundary


def rotate(vector, angle):
    """
    Rotate a 2D vector by a given angle (in radians).
    """
    rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)],
                                [np.sin(angle), np.cos(angle)]])
    return rotation_matrix.dot(vector)

def simulate_brownian_motion(arena_size, num_steps, speed=1, direction=np.array([1, 0])):
    # Initialize the robot and the boundary
    robot = Robot(position=np.array([arena_size/2, arena_size/2]), direction=direction, speed=speed, arena_size=arena_size)
    boundary = np.zeros((arena_size, arena_size))
    boundary[int(robot.position[1]), int(robot.position[0])] = 1

    # Create a list of boundary snapshots for creating the GIF
    boundary_snapshots = [boundary.copy()]

    # Simulate the robot's movement
    for i in range(num_steps):
        boundary = robot.update(boundary)
        boundary_snapshots.append(boundary.copy())

    # Create the GIF from the boundary snapshots
    images = []
    for boundary in boundary_snapshots:
        fig, ax = plt.subplots()
        ax.imshow(boundary, cmap='gray_r')
        ax.axis('off')
        plt.tight_layout()
        plt.savefig('frame.png')
        images.append(imageio.imread('frame.png'))
        plt.close()

    imageio.mimsave('brownian_motion.gif', images, fps=20)

if __name__ == '__main__':
    simulate_brownian_motion(100, 90) # arena_size, num_steps